(()=>{"use strict";var t={76:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.MultiHeadAttention=void 0,e.MultiHeadAttention=class{embeddingDim;numHeads;headDim;wq;wk;wv;wo;gradWq;gradWk;gradWv;gradWo;lastInput=[];lastQ=[];lastK=[];lastV=[];lastScores=[];lastAttentionWeights=[];lastHeadOutputs=[];lastConcatenated=[];learningRate=.001;constructor(t,e=4){if(t%e!==0)throw new Error(`embeddingDim (${t}) must be divisible by numHeads (${e})`);this.embeddingDim=t,this.numHeads=e,this.headDim=t/e;const i=Math.sqrt(1/t);this.wq=this.initHeadWeights(e,t,this.headDim,i),this.wk=this.initHeadWeights(e,t,this.headDim,i),this.wv=this.initHeadWeights(e,t,this.headDim,i),this.wo=this.initWeights(t,t,i),this.gradWq=this.initHeadWeights(e,t,this.headDim,0),this.gradWk=this.initHeadWeights(e,t,this.headDim,0),this.gradWv=this.initHeadWeights(e,t,this.headDim,0),this.gradWo=this.initWeights(t,t,0)}initWeights(t,e,i){return Array.from({length:t},()=>Array.from({length:e},()=>(2*Math.random()-1)*i))}initHeadWeights(t,e,i,s){return Array.from({length:t},()=>this.initWeights(e,i,s))}vecMatmul(t,e){const i=new Array(e[0].length).fill(0);for(let s=0;s<e[0].length;s++)for(let r=0;r<t.length;r++)i[s]+=t[r]*e[r][s];return i}softmax(t){return t.map(t=>{const e=Math.max(...t),i=t.map(t=>Math.exp(t-e)),s=i.reduce((t,e)=>t+e,1e-8);return i.map(t=>t/s)})}softmaxBackward(t,e){const i=[];for(let s=0;s<t.length;s++){const r=e[s],a=t[s],n=a.reduce((t,e,i)=>t+e*r[i],0);i[s]=r.map((t,e)=>t*(a[e]-n))}return i}forward(t){this.lastInput=t.map(t=>[...t]);const e=t.length;this.lastQ=[],this.lastK=[],this.lastV=[],this.lastScores=[],this.lastAttentionWeights=[],this.lastHeadOutputs=[];const i=[];for(let s=0;s<this.numHeads;s++){const r=t.map(t=>this.vecMatmul(t,this.wq[s])),a=t.map(t=>this.vecMatmul(t,this.wk[s])),n=t.map(t=>this.vecMatmul(t,this.wv[s]));this.lastQ[s]=r,this.lastK[s]=a,this.lastV[s]=n;const o=Math.sqrt(this.headDim),h=[];for(let t=0;t<e;t++){h[t]=[];for(let i=0;i<e;i++){let e=0;for(let s=0;s<this.headDim;s++)e+=r[t][s]*a[i][s];h[t][i]=e/o}}this.lastScores[s]=h;const d=this.softmax(h);this.lastAttentionWeights[s]=d;const l=[];for(let t=0;t<e;t++){l[t]=new Array(this.headDim).fill(0);for(let i=0;i<e;i++)for(let e=0;e<this.headDim;e++)l[t][e]+=d[t][i]*n[i][e]}this.lastHeadOutputs[s]=l,i[s]=l}const s=[];for(let t=0;t<e;t++){s[t]=[];for(let e=0;e<this.numHeads;e++)for(let r=0;r<this.headDim;r++)s[t].push(i[e][t][r])}return this.lastConcatenated=s,s.map(t=>this.vecMatmul(t,this.wo))}backward(t){const e=t.length,i=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let s=0;s<e;s++)for(let e=0;e<this.embeddingDim;e++){const r=t[s][e];for(let t=0;t<this.embeddingDim;t++)this.gradWo[t][e]+=r*this.lastConcatenated[s][t],i[s][t]+=r*this.wo[t][e]}const s=[];for(let t=0;t<this.numHeads;t++){s[t]=[];for(let r=0;r<e;r++){s[t][r]=[];for(let e=0;e<this.headDim;e++){const a=t*this.headDim+e;s[t][r][e]=i[r][a]}}}const r=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<this.numHeads;t++){const i=this.lastQ[t],a=this.lastK[t],n=this.lastV[t],o=this.lastAttentionWeights[t],h=s[t],d=Array.from({length:e},()=>new Array(e).fill(0)),l=Array.from({length:e},()=>new Array(this.headDim).fill(0));for(let t=0;t<e;t++)for(let i=0;i<this.headDim;i++){const s=h[t][i];for(let r=0;r<e;r++)d[t][r]+=s*n[r][i],l[r][i]+=s*o[t][r]}const m=this.softmaxBackward(d,o),c=Math.sqrt(this.headDim),u=m.map(t=>t.map(t=>t/c)),g=Array.from({length:e},()=>new Array(this.headDim).fill(0)),f=Array.from({length:e},()=>new Array(this.headDim).fill(0));for(let t=0;t<e;t++)for(let s=0;s<e;s++){const e=u[t][s];for(let r=0;r<this.headDim;r++)g[t][r]+=e*a[s][r],f[s][r]+=e*i[t][r]}for(let i=0;i<e;i++)for(let e=0;e<this.headDim;e++){const s=g[i][e],a=f[i][e],n=l[i][e];for(let o=0;o<this.embeddingDim;o++)this.gradWq[t][o][e]+=s*this.lastInput[i][o],this.gradWk[t][o][e]+=a*this.lastInput[i][o],this.gradWv[t][o][e]+=n*this.lastInput[i][o],r[i][o]+=s*this.wq[t][o][e],r[i][o]+=a*this.wk[t][o][e],r[i][o]+=n*this.wv[t][o][e]}}return r}zeroGrad(){for(let t=0;t<this.numHeads;t++)for(let e=0;e<this.embeddingDim;e++)for(let i=0;i<this.headDim;i++)this.gradWq[t][e][i]=0,this.gradWk[t][e][i]=0,this.gradWv[t][e][i]=0;for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.embeddingDim;e++)this.gradWo[t][e]=0}updateParameters(){for(let t=0;t<this.numHeads;t++)for(let e=0;e<this.embeddingDim;e++)for(let i=0;i<this.headDim;i++){const s=Math.max(-5,Math.min(5,this.gradWq[t][e][i]));this.wq[t][e][i]+=this.learningRate*s;const r=Math.max(-5,Math.min(5,this.gradWk[t][e][i]));this.wk[t][e][i]+=this.learningRate*r;const a=Math.max(-5,Math.min(5,this.gradWv[t][e][i]));this.wv[t][e][i]+=this.learningRate*a}for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.embeddingDim;e++){const i=Math.max(-5,Math.min(5,this.gradWo[t][e]));this.wo[t][e]+=this.learningRate*i}}updateWithOptimizer(t,e){for(let i=0;i<this.numHeads;i++){const s=this.gradWq[i].map(t=>t.map(t=>Math.max(-5,Math.min(5,t)))),r=this.gradWk[i].map(t=>t.map(t=>Math.max(-5,Math.min(5,t)))),a=this.gradWv[i].map(t=>t.map(t=>Math.max(-5,Math.min(5,t))));t.update(`${e}_wq_head${i}`,this.wq[i],s),t.update(`${e}_wk_head${i}`,this.wk[i],r),t.update(`${e}_wv_head${i}`,this.wv[i],a)}const i=this.gradWo.map(t=>t.map(t=>Math.max(-5,Math.min(5,t))));t.update(`${e}_wo`,this.wo,i)}}},112:(t,e)=>{function i(t,e=1e-8){const i=t.reduce((t,e)=>t+e,0)/t.length,s=t.reduce((t,e)=>t+Math.pow(e-i,2),0)/t.length,r=Math.sqrt(s+e);return{normalized:t.map(t=>(t-i)/r),mean:i,std:r}}Object.defineProperty(e,"__esModule",{value:!0}),e.LayerNorm=void 0,e.layerNormalize=i,e.batchLayerNormalize=function(t,e=1e-8){return t.map(t=>i(t,e).normalized)},e.LayerNorm=class{epsilon;gamma;beta;dim;learningRate=.01;gradGamma;gradBeta;lastMean=[];lastVar=[];lastStd=[];lastNormalized=[];lastInput=[];constructor(t,e=1e-8){this.dim=t,this.epsilon=e,this.gamma=Array(t).fill(1),this.beta=Array(t).fill(0),this.gradGamma=Array(t).fill(0),this.gradBeta=Array(t).fill(0)}forward(t){const e=t.reduce((t,e)=>t+e,0)/this.dim,i=t.reduce((t,i)=>t+Math.pow(i-e,2),0)/this.dim,s=Math.sqrt(i+this.epsilon);return t.map(t=>(t-e)/s).map((t,e)=>this.gamma[e]*t+this.beta[e])}forwardBatch(t){return this.lastInput=t.map(t=>[...t]),this.lastMean=[],this.lastVar=[],this.lastStd=[],this.lastNormalized=[],t.map((t,e)=>{const i=t.reduce((t,e)=>t+e,0)/this.dim,s=t.reduce((t,e)=>t+Math.pow(e-i,2),0)/this.dim,r=Math.sqrt(s+this.epsilon);this.lastMean[e]=i,this.lastVar[e]=s,this.lastStd[e]=r;const a=t.map(t=>(t-i)/r);return this.lastNormalized[e]=[...a],a.map((t,e)=>this.gamma[e]*t+this.beta[e])})}backward(t,e,i){const s=this.dim,r=(this.lastMean[i],this.lastStd[i]),a=this.lastNormalized[i];for(let t=0;t<s;t++)this.gradGamma[t]+=e[t]*a[t],this.gradBeta[t]+=e[t];const n=e.map((t,e)=>t*this.gamma[e]),o=n.reduce((t,e)=>t+e,0)/s,h=n.reduce((t,e,i)=>t+e*a[i],0)/s;return n.map((t,e)=>(t-o-a[e]*h)/r)}zeroGrad(){this.gradGamma.fill(0),this.gradBeta.fill(0)}updateParameters(){for(let t=0;t<this.dim;t++){const e=Math.max(-1,Math.min(1,this.gradGamma[t])),i=Math.max(-1,Math.min(1,this.gradBeta[t]));this.gamma[t]-=this.learningRate*e,this.beta[t]-=this.learningRate*i}}updateWithOptimizer(t,e){const i=this.gradGamma.map(t=>Math.max(-5,Math.min(5,t))),s=this.gradBeta.map(t=>Math.max(-5,Math.min(5,t)));t.update1D(`${e}_gamma`,this.gamma,i),t.update1D(`${e}_beta`,this.beta,s)}backwardBatch(t,e){return t.map((t,i)=>this.backward(t,e[i],i))}}},156:(t,e)=>{function i(t,e){const i=new Array(e);for(let s=0;s<e;s++){const r=t/Math.pow(1e4,2*Math.floor(s/2)/e);i[s]=s%2==0?Math.sin(r):Math.cos(r)}return i}Object.defineProperty(e,"__esModule",{value:!0}),e.PositionalEncodingCache=void 0,e.getPositionalEncoding=i,e.addPositionalEncoding=function(t,e){return t.map((t,s)=>{const r=i(s,e);return t.map((t,e)=>t+r[e])})},e.PositionalEncodingCache=class{cache=new Map;embeddingDim;constructor(t){this.embeddingDim=t}get(t){const e=`${t}`;if(!this.cache.has(e)){const s=i(t,this.embeddingDim);this.cache.set(e,s)}return this.cache.get(e)}addToEmbedding(t,e){const i=this.get(e);return t.map((t,e)=>t+i[e])}addToEmbeddings(t){return t.map((t,e)=>this.addToEmbedding(t,e))}}},396:(t,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.SimpleLLM=void 0;const s=i(530),r=i(504),a=i(642),n=i(976),o=i(156),h=i(404),d=i(655);class l{tokenizer;embedding;transformers;outputLayer;positionalEncoding;vocabSize;embeddingDim;numLayers;numHeads;optimizer;constructor(t,e=16,i=2,h=1){this.vocabSize=t.length,this.embeddingDim=e,this.numLayers=i,this.numHeads=h,this.tokenizer=new s.SimpleTokenizer(t),this.embedding=new a.EmbeddingLayer(t.length,e),this.transformers=Array.from({length:i},()=>h>1?new r.MultiHeadTransformer(e,h):new r.SimpleTransformer(e)),this.outputLayer=new n.OutputLayer(e,t.length),this.positionalEncoding=new o.PositionalEncodingCache(e)}getSpecialTokenIndices(){const t=new Set;return["[PAD]","[UNK]","[EOS]"].forEach(e=>{const i=this.tokenizer.vocabMap[e];void 0!==i&&t.add(i)}),t}predict(t,e=10){let i=this.tokenizer.encode(t);const s=this.getSpecialTokenIndices(),r=this.tokenizer.vocabMap["[EOS]"];console.log("Input text:",t),console.log("Encoded tokens:",i),console.log("Special token indices:",Array.from(s)),console.log("Vocab size:",this.vocabSize);for(let t=0;t<e;t++){const e=i.map(t=>this.embedding.forward(t));let a=this.positionalEncoding.addToEmbeddings(e);for(const t of this.transformers)a=t.forward(a);const n=a[a.length-1],o=this.outputLayer.forward(n),h=this.outputLayer.softmax(o),d=h.map((t,e)=>({prob:t,idx:e,word:this.tokenizer.vocab[e]})).sort((t,e)=>e.prob-t.prob).slice(0,5);console.log(`Step ${t} - Top 5 probs (before filter):`,d);const l=h.map((t,e)=>s.has(e)?0:t),m=l.reduce((t,e)=>t+e,1e-10),c=l.map(t=>t/m),u=Math.max(...c),g=c.indexOf(u);console.log(`Step ${t}: nextToken=${g}, maxProb=${u.toFixed(4)}, word="${this.tokenizer.vocab[g]}"`);const f=c.map((t,e)=>({prob:t,idx:e,word:this.tokenizer.vocab[e]})).sort((t,e)=>e.prob-t.prob).slice(0,5);if(console.log(`Step ${t} - Top 5 probs (after filter):`,f),i.push(g),g===r)break}const a=this.tokenizer.decode(i);return console.log("Final result:",a),a}setOptimizer(t){this.optimizer=t}train(t,e=10,i="adam",s=.001){this.optimizer||(this.optimizer="adam"===i?new h.AdamOptimizer(s):new h.SGDOptimizer(s));for(let i=0;i<e;i++){console.log(`Epoch ${i+1}/${e}`);let s=0;t.forEach(({input:t,target:e})=>{this.embedding.zeroGrad();for(const t of this.transformers)t.zeroGrad(),t.layerNorm1.zeroGrad(),t.layerNorm2.zeroGrad();this.outputLayer.zeroGrad();const i=this.tokenizer.encode(t),a=this.tokenizer.encode(e),n=i.map(t=>this.embedding.forward(t));let o=this.positionalEncoding.addToEmbeddings(n);for(const t of this.transformers)o=t.forward(o);const h=o,d=Math.min(h.length,a.length),l=Array.from({length:h.length},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<d;t++){const e=this.outputLayer.forward(h[t]),i=this.outputLayer.softmax(e),r=i.map(t=>-t);r[a[t]]+=1,s-=Math.log(i[a[t]]+1e-10);const n=this.outputLayer.backward(h[t],r);for(let e=0;e<this.embeddingDim;e++)l[t][e]=n[e]}let m=l;for(let t=this.transformers.length-1;t>=0;t--)m=this.transformers[t].backward(m);const c=m;for(let t=0;t<i.length&&t<c.length;t++)this.embedding.backward(i[t],c[t]);if(this.optimizer){this.embedding.updateWithOptimizer(this.optimizer),this.outputLayer.updateWithOptimizer(this.optimizer);for(let t=0;t<this.transformers.length;t++){const e=this.transformers[t];r.MultiHeadTransformer,e.updateWithOptimizer(this.optimizer,`transformer_${t}`)}}else{this.embedding.updateParametersManual(),this.outputLayer.updateParameters();for(const t of this.transformers)t.updateParameters(),t.layerNorm1.updateParameters(),t.layerNorm2.updateParameters()}});const a=s/t.length;console.log(`Epoch ${i+1}/${e} - Loss: ${a.toFixed(4)}`)}}serialize(){const t={version:"2.0",config:{vocabSize:this.vocabSize,embeddingDim:this.embeddingDim,numLayers:this.numLayers,numHeads:this.numHeads,vocab:this.tokenizer.vocab},weights:{embedding:this.embedding.weights,transformers:this.transformers.map(t=>t instanceof r.MultiHeadTransformer?{type:"multi-head",multiHeadAttention:{wq:t.multiHeadAttention.wq,wk:t.multiHeadAttention.wk,wv:t.multiHeadAttention.wv,wo:t.multiHeadAttention.wo},w1:t.w1,w2:t.w2,layerNorm1:{gamma:t.layerNorm1.gamma,beta:t.layerNorm1.beta},layerNorm2:{gamma:t.layerNorm2.gamma,beta:t.layerNorm2.beta}}:{type:"single-head",wq:t.wq,wk:t.wk,wv:t.wv,w1:t.w1,w2:t.w2,layerNorm1:{gamma:t.layerNorm1.gamma,beta:t.layerNorm1.beta},layerNorm2:{gamma:t.layerNorm2.gamma,beta:t.layerNorm2.beta}}),output:{weights:this.outputLayer.weights,bias:this.outputLayer.bias}}};return(0,d.encode)(t)}static deserialize(t){const e=(0,d.decode)(t),{config:i,weights:s}=e,a=new l(i.vocab,i.embeddingDim,i.numLayers,i.numHeads);return a.embedding.weights=s.embedding,s.transformers.forEach((t,e)=>{const i=a.transformers[e];"multi-head"===t.type&&i instanceof r.MultiHeadTransformer?(i.multiHeadAttention.wq=t.multiHeadAttention.wq,i.multiHeadAttention.wk=t.multiHeadAttention.wk,i.multiHeadAttention.wv=t.multiHeadAttention.wv,i.multiHeadAttention.wo=t.multiHeadAttention.wo,i.w1=t.w1,i.w2=t.w2,i.layerNorm1.gamma=t.layerNorm1.gamma,i.layerNorm1.beta=t.layerNorm1.beta,i.layerNorm2.gamma=t.layerNorm2.gamma,i.layerNorm2.beta=t.layerNorm2.beta):i instanceof r.SimpleTransformer&&(i.wq=t.wq,i.wk=t.wk,i.wv=t.wv,i.w1=t.w1,i.w2=t.w2,i.layerNorm1.gamma=t.layerNorm1.gamma,i.layerNorm1.beta=t.layerNorm1.beta,i.layerNorm2.gamma=t.layerNorm2.gamma,i.layerNorm2.beta=t.layerNorm2.beta)}),a.outputLayer.weights=s.output.weights,a.outputLayer.bias=s.output.bias,a}}e.SimpleLLM=l},404:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.AdamOptimizer=e.SGDOptimizer=e.Optimizer=void 0;class i{learningRate;state=new Map;constructor(t=.001){this.learningRate=t}setLearningRate(t){this.learningRate=t}getLearningRate(){return this.learningRate}reset(){this.state.clear()}}e.Optimizer=i,e.SGDOptimizer=class extends i{momentum;dampening;nesterov;constructor(t=.001,e=0,i=0,s=!1){super(t),this.momentum=e,this.dampening=i,this.nesterov=s}update(t,e,i){if(0===this.momentum){for(let t=0;t<e.length;t++)for(let s=0;s<e[t].length;s++)e[t][s]+=this.learningRate*i[t][s];return}let s=this.state.get(t);s||(s={velocity:e.map(t=>new Array(t.length).fill(0))},this.state.set(t,s));const r=s.velocity;for(let t=0;t<e.length;t++)for(let s=0;s<e[t].length;s++){let a=r[t][s]*this.momentum;this.dampening>0?a+=(1-this.dampening)*i[t][s]:a+=i[t][s],r[t][s]=a,this.nesterov?e[t][s]+=this.learningRate*(i[t][s]+this.momentum*a):e[t][s]+=this.learningRate*a}}update1D(t,e,i){if(0===this.momentum){for(let t=0;t<e.length;t++)e[t]+=this.learningRate*i[t];return}let s=this.state.get(t);s||(s={velocity:new Array(e.length).fill(0)},this.state.set(t,s));const r=s.velocity;for(let t=0;t<e.length;t++){let s=r[t]*this.momentum;this.dampening>0?s+=(1-this.dampening)*i[t]:s+=i[t],r[t]=s,this.nesterov?e[t]+=this.learningRate*(i[t]+this.momentum*s):e[t]+=this.learningRate*s}}},e.AdamOptimizer=class extends i{beta1;beta2;epsilon;timestep=0;constructor(t=.001,e=.9,i=.999,s=1e-8){super(t),this.beta1=e,this.beta2=i,this.epsilon=s}update(t,e,i){let s=this.state.get(t);s||(s={m:e.map(t=>new Array(t.length).fill(0)),v:e.map(t=>new Array(t.length).fill(0)),t:0},this.state.set(t,s));const r=s.m,a=s.v;s.t+=1;const n=s.t;for(let t=0;t<e.length;t++)for(let s=0;s<e[t].length;s++){r[t][s]=this.beta1*r[t][s]+(1-this.beta1)*i[t][s],a[t][s]=this.beta2*a[t][s]+(1-this.beta2)*i[t][s]*i[t][s];const o=r[t][s]/(1-Math.pow(this.beta1,n)),h=a[t][s]/(1-Math.pow(this.beta2,n));e[t][s]+=this.learningRate*o/(Math.sqrt(h)+this.epsilon)}}update1D(t,e,i){let s=this.state.get(t);s||(s={m:new Array(e.length).fill(0),v:new Array(e.length).fill(0),t:0},this.state.set(t,s));const r=s.m,a=s.v;s.t+=1;const n=s.t;for(let t=0;t<e.length;t++){r[t]=this.beta1*r[t]+(1-this.beta1)*i[t],a[t]=this.beta2*a[t]+(1-this.beta2)*i[t]*i[t];const s=r[t]/(1-Math.pow(this.beta1,n)),o=a[t]/(1-Math.pow(this.beta2,n));e[t]+=this.learningRate*s/(Math.sqrt(o)+this.epsilon)}}reset(){super.reset(),this.timestep=0}}},504:(t,e,i)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.MultiHeadTransformer=e.SimpleTransformer=void 0;const s=i(112),r=i(76);e.SimpleTransformer=class{wq;wk;wv;w1;w2;gradWq;gradWk;gradWv;gradW1;gradW2;layerNorm1;layerNorm2;learningRate=.001;embeddingDim;lastInput=[];lastQ=[];lastK=[];lastV=[];lastScores=[];lastAttentionWeights=[];lastAttnOutput=[];lastAttnResidual=[];lastAttnNorm=[];lastFF1=[];lastFFOutput=[];lastFFResidual=[];constructor(t){this.embeddingDim=t;const e=Math.sqrt(1/t);this.wq=this.initWeights(t,t,e),this.wk=this.initWeights(t,t,e),this.wv=this.initWeights(t,t,e),this.w1=this.initWeights(t,t,e),this.w2=this.initWeights(t,t,e),this.gradWq=this.initWeights(t,t,0),this.gradWk=this.initWeights(t,t,0),this.gradWv=this.initWeights(t,t,0),this.gradW1=this.initWeights(t,t,0),this.gradW2=this.initWeights(t,t,0),this.layerNorm1=new s.LayerNorm(t),this.layerNorm2=new s.LayerNorm(t)}initWeights(t,e,i){return Array.from({length:t},()=>Array.from({length:e},()=>(2*Math.random()-1)*i))}matmul(t,e){const i=[];for(let s=0;s<t.length;s++){i[s]=[];for(let r=0;r<e[0].length;r++){let a=0;for(let i=0;i<t[0].length;i++)a+=t[s][i]*e[i][r];i[s][r]=a}}return i}vecMatmul(t,e){const i=new Array(e[0].length).fill(0);for(let s=0;s<e[0].length;s++)for(let r=0;r<t.length;r++)i[s]+=t[r]*e[r][s];return i}transpose(t){const e=t.length,i=t[0].length,s=Array.from({length:i},()=>new Array(e));for(let r=0;r<e;r++)for(let e=0;e<i;e++)s[e][r]=t[r][e];return s}softmax(t){return t.map(t=>{const e=Math.max(...t),i=t.map(t=>Math.exp(t-e)),s=i.reduce((t,e)=>t+e,1e-8);return i.map(t=>t/s)})}softmaxBackward(t,e){const i=[];for(let s=0;s<t.length;s++){const r=e[s],a=t[s],n=a.reduce((t,e,i)=>t+e*r[i],0);i[s]=r.map((t,e)=>t*(a[e]-n))}return i}attention(t){const e=t.length,i=Math.sqrt(this.embeddingDim);this.lastQ=t.map(t=>this.vecMatmul(t,this.wq)),this.lastK=t.map(t=>this.vecMatmul(t,this.wk)),this.lastV=t.map(t=>this.vecMatmul(t,this.wv)),this.lastScores=[];for(let t=0;t<e;t++){this.lastScores[t]=[];for(let s=0;s<e;s++){let e=0;for(let i=0;i<this.embeddingDim;i++)e+=this.lastQ[t][i]*this.lastK[s][i];this.lastScores[t][s]=e/i}}this.lastAttentionWeights=this.softmax(this.lastScores);const s=[];for(let t=0;t<e;t++){s[t]=new Array(this.embeddingDim).fill(0);for(let i=0;i<e;i++)for(let e=0;e<this.embeddingDim;e++)s[t][e]+=this.lastAttentionWeights[t][i]*this.lastV[i][e]}return s}feedForward(t){return this.lastFF1=t.map(t=>this.vecMatmul(t,this.w1).map(t=>Math.max(0,t))),this.lastFF1.map(t=>this.vecMatmul(t,this.w2))}forward(t){return this.lastInput=t.map(t=>[...t]),this.lastAttnOutput=this.attention(t),this.lastAttnResidual=this.lastAttnOutput.map((e,i)=>e.map((e,s)=>e+t[i][s])),this.lastAttnNorm=this.layerNorm1.forwardBatch(this.lastAttnResidual),this.lastFFOutput=this.feedForward(this.lastAttnNorm),this.lastFFResidual=this.lastFFOutput.map((t,e)=>t.map((t,i)=>t+this.lastAttnNorm[e][i])),this.layerNorm2.forwardBatch(this.lastFFResidual)}backward(t){const e=t.length,i=Math.sqrt(this.embeddingDim);let s=this.layerNorm2.backwardBatch(this.lastFFResidual,t);const r=s.map(t=>[...t]),a=s.map(t=>[...t]),n=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const i=r[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradW2[s][e]+=i*this.lastFF1[t][s],n[t][s]+=i*this.w2[s][e]}const o=n.map((t,e)=>t.map((t,i)=>this.lastFF1[e][i]>0?t:0));for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const i=o[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradW1[s][e]+=i*this.lastAttnNorm[t][s],a[t][s]+=i*this.w1[s][e]}const h=this.layerNorm1.backwardBatch(this.lastAttnResidual,a),d=h.map(t=>[...t]),l=h.map(t=>[...t]),m=Array.from({length:e},()=>new Array(e).fill(0)),c=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let i=0;i<this.embeddingDim;i++){const s=d[t][i];for(let r=0;r<e;r++)m[t][r]+=s*this.lastV[r][i],c[r][i]+=s*this.lastAttentionWeights[t][r]}const u=this.softmaxBackward(m,this.lastAttentionWeights).map(t=>t.map(t=>t/i)),g=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0)),f=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let i=0;i<e;i++){const e=u[t][i];for(let s=0;s<this.embeddingDim;s++)g[t][s]+=e*this.lastK[i][s],f[i][s]+=e*this.lastQ[t][s]}const p=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const i=g[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradWq[s][e]+=i*this.lastInput[t][s],p[t][s]+=i*this.wq[s][e]}for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const i=f[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradWk[s][e]+=i*this.lastInput[t][s],p[t][s]+=i*this.wk[s][e]}for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const i=c[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradWv[s][e]+=i*this.lastInput[t][s],p[t][s]+=i*this.wv[s][e]}return l.map((t,e)=>t.map((t,i)=>t+p[e][i]))}zeroGrad(){for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.embeddingDim;e++)this.gradWq[t][e]=0,this.gradWk[t][e]=0,this.gradWv[t][e]=0,this.gradW1[t][e]=0,this.gradW2[t][e]=0}updateParameters(){for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.embeddingDim;e++){const i=Math.max(-5,Math.min(5,this.gradWq[t][e]));this.wq[t][e]+=this.learningRate*i;const s=Math.max(-5,Math.min(5,this.gradWk[t][e]));this.wk[t][e]+=this.learningRate*s;const r=Math.max(-5,Math.min(5,this.gradWv[t][e]));this.wv[t][e]+=this.learningRate*r;const a=Math.max(-5,Math.min(5,this.gradW1[t][e]));this.w1[t][e]+=this.learningRate*a;const n=Math.max(-5,Math.min(5,this.gradW2[t][e]));this.w2[t][e]+=this.learningRate*n}}updateWithOptimizer(t,e){const i=this.gradWq.map(t=>t.map(t=>Math.max(-5,Math.min(5,t)))),s=this.gradWk.map(t=>t.map(t=>Math.max(-5,Math.min(5,t)))),r=this.gradWv.map(t=>t.map(t=>Math.max(-5,Math.min(5,t)))),a=this.gradW1.map(t=>t.map(t=>Math.max(-5,Math.min(5,t)))),n=this.gradW2.map(t=>t.map(t=>Math.max(-5,Math.min(5,t))));t.update(`${e}_wq`,this.wq,i),t.update(`${e}_wk`,this.wk,s),t.update(`${e}_wv`,this.wv,r),t.update(`${e}_w1`,this.w1,a),t.update(`${e}_w2`,this.w2,n),this.layerNorm1.updateWithOptimizer(t,`${e}_ln1`),this.layerNorm2.updateWithOptimizer(t,`${e}_ln2`)}},e.MultiHeadTransformer=class{multiHeadAttention;w1;w2;gradW1;gradW2;layerNorm1;layerNorm2;learningRate=.001;embeddingDim;numHeads;lastInput=[];lastAttnOutput=[];lastAttnResidual=[];lastAttnNorm=[];lastFF1=[];lastFFOutput=[];lastFFResidual=[];constructor(t,e=4){this.embeddingDim=t,this.numHeads=e,this.multiHeadAttention=new r.MultiHeadAttention(t,e);const i=Math.sqrt(1/t);this.w1=this.initWeights(t,t,i),this.w2=this.initWeights(t,t,i),this.gradW1=this.initWeights(t,t,0),this.gradW2=this.initWeights(t,t,0),this.layerNorm1=new s.LayerNorm(t),this.layerNorm2=new s.LayerNorm(t)}initWeights(t,e,i){return Array.from({length:t},()=>Array.from({length:e},()=>(2*Math.random()-1)*i))}vecMatmul(t,e){const i=new Array(e[0].length).fill(0);for(let s=0;s<e[0].length;s++)for(let r=0;r<t.length;r++)i[s]+=t[r]*e[r][s];return i}feedForward(t){return this.lastFF1=t.map(t=>this.vecMatmul(t,this.w1).map(t=>Math.max(0,t))),this.lastFF1.map(t=>this.vecMatmul(t,this.w2))}forward(t){return this.lastInput=t.map(t=>[...t]),this.lastAttnOutput=this.multiHeadAttention.forward(t),this.lastAttnResidual=this.lastAttnOutput.map((e,i)=>e.map((e,s)=>e+t[i][s])),this.lastAttnNorm=this.layerNorm1.forwardBatch(this.lastAttnResidual),this.lastFFOutput=this.feedForward(this.lastAttnNorm),this.lastFFResidual=this.lastFFOutput.map((t,e)=>t.map((t,i)=>t+this.lastAttnNorm[e][i])),this.layerNorm2.forwardBatch(this.lastFFResidual)}backward(t){const e=t.length;let i=this.layerNorm2.backwardBatch(this.lastFFResidual,t);const s=i.map(t=>[...t]),r=i.map(t=>[...t]),a=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const i=s[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradW2[s][e]+=i*this.lastFF1[t][s],a[t][s]+=i*this.w2[s][e]}const n=a.map((t,e)=>t.map((t,i)=>this.lastFF1[e][i]>0?t:0));for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const i=n[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradW1[s][e]+=i*this.lastAttnNorm[t][s],r[t][s]+=i*this.w1[s][e]}const o=this.layerNorm1.backwardBatch(this.lastAttnResidual,r),h=o.map(t=>[...t]),d=o.map(t=>[...t]),l=this.multiHeadAttention.backward(h);return d.map((t,e)=>t.map((t,i)=>t+l[e][i]))}zeroGrad(){this.multiHeadAttention.zeroGrad();for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.embeddingDim;e++)this.gradW1[t][e]=0,this.gradW2[t][e]=0}updateParameters(){this.multiHeadAttention.updateParameters();for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.embeddingDim;e++){const i=Math.max(-5,Math.min(5,this.gradW1[t][e]));this.w1[t][e]+=this.learningRate*i;const s=Math.max(-5,Math.min(5,this.gradW2[t][e]));this.w2[t][e]+=this.learningRate*s}}updateWithOptimizer(t,e){this.multiHeadAttention.updateWithOptimizer(t,`${e}_mha`);const i=this.gradW1.map(t=>t.map(t=>Math.max(-5,Math.min(5,t)))),s=this.gradW2.map(t=>t.map(t=>Math.max(-5,Math.min(5,t))));t.update(`${e}_w1`,this.w1,i),t.update(`${e}_w2`,this.w2,s),this.layerNorm1.updateWithOptimizer(t,`${e}_ln1`),this.layerNorm2.updateWithOptimizer(t,`${e}_ln2`)}}},530:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.SimpleTokenizer=void 0,e.SimpleTokenizer=class{vocab;vocabMap;unkIndex;constructor(t){this.vocab=t,this.vocabMap=Object.fromEntries(t.map((t,e)=>[t,e])),this.unkIndex=this.vocabMap["[UNK]"]??0}encode(t){return t.toLowerCase().split(" ").map(t=>t.trim()).filter(t=>t.length>0).map(t=>this.vocabMap[t]??this.unkIndex)}decode(t){return t.map(t=>this.vocab[t]??"[UNK]").join(" ")}}},642:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.EmbeddingLayer=void 0,e.EmbeddingLayer=class{weights;embeddingDim;vocabSize;learningRate=.001;gradWeights=new Map;constructor(t,e,i="xavier"){let s;switch(this.embeddingDim=e,this.vocabSize=t,i){case"xavier":default:s=Math.sqrt(1/e);break;case"he":s=Math.sqrt(2/e);break;case"normal":s=.01}this.weights=Array.from({length:t},()=>Array.from({length:e},()=>(2*Math.random()-1)*s))}forward(t){return t<0||t>=this.weights.length?Array(this.embeddingDim).fill(0):[...this.weights[t]]}backward(t,e){if(t<0||t>=this.weights.length)return;this.gradWeights.has(t)||this.gradWeights.set(t,new Array(this.embeddingDim).fill(0));const i=this.gradWeights.get(t);for(let t=0;t<this.embeddingDim;t++)i[t]+=e[t]}updateParametersManual(){for(const[t,e]of this.gradWeights.entries())for(let i=0;i<this.embeddingDim;i++){const s=Math.max(-5,Math.min(5,e[i]));this.weights[t][i]+=this.learningRate*s}this.gradWeights.clear()}updateWithOptimizer(t){for(const[e,i]of this.gradWeights.entries()){const s=i.map(t=>Math.max(-5,Math.min(5,t))),r=[this.weights[e]],a=[s];t.update(`embedding_${e}`,r,a)}this.gradWeights.clear()}zeroGrad(){this.gradWeights.clear()}}},655:(t,e,i)=>{i.r(e),i.d(e,{DecodeError:()=>o,Decoder:()=>N,EXT_TIMESTAMP:()=>m,Encoder:()=>x,ExtData:()=>n,ExtensionCodec:()=>M,decode:()=>F,decodeArrayStream:()=>O,decodeAsync:()=>H,decodeMulti:()=>T,decodeMultiStream:()=>R,decodeTimestampExtension:()=>y,decodeTimestampToTimeSpec:()=>w,encode:()=>A,encodeDateToTimeSpec:()=>f,encodeTimeSpecToTimestamp:()=>g,encodeTimestampExtension:()=>p});const s=new TextEncoder;function r(t,e,i){let s=e;const r=s+i,a=[];let n="";for(;s<r;){const e=t[s++];if(128&e)if(192==(224&e)){const i=63&t[s++];a.push((31&e)<<6|i)}else if(224==(240&e)){const i=63&t[s++],r=63&t[s++];a.push((31&e)<<12|i<<6|r)}else if(240==(248&e)){let i=(7&e)<<18|(63&t[s++])<<12|(63&t[s++])<<6|63&t[s++];i>65535&&(i-=65536,a.push(i>>>10&1023|55296),i=56320|1023&i),a.push(i)}else a.push(e);else a.push(e);a.length>=4096&&(n+=String.fromCharCode(...a),a.length=0)}return a.length>0&&(n+=String.fromCharCode(...a)),n}const a=new TextDecoder;class n{constructor(t,e){this.type=t,this.data=e}}class o extends Error{constructor(t){super(t);const e=Object.create(o.prototype);Object.setPrototypeOf(this,e),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:o.name})}}const h=4294967295;function d(t,e,i){const s=Math.floor(i/4294967296),r=i;t.setUint32(e,s),t.setUint32(e+4,r)}function l(t,e){return 4294967296*t.getInt32(e)+t.getUint32(e+4)}const m=-1,c=4294967295,u=17179869183;function g({sec:t,nsec:e}){if(t>=0&&e>=0&&t<=u){if(0===e&&t<=c){const e=new Uint8Array(4);return new DataView(e.buffer).setUint32(0,t),e}{const i=t/4294967296,s=4294967295&t,r=new Uint8Array(8),a=new DataView(r.buffer);return a.setUint32(0,e<<2|3&i),a.setUint32(4,s),r}}{const i=new Uint8Array(12),s=new DataView(i.buffer);return s.setUint32(0,e),d(s,4,t),i}}function f(t){const e=t.getTime(),i=Math.floor(e/1e3),s=1e6*(e-1e3*i),r=Math.floor(s/1e9);return{sec:i+r,nsec:s-1e9*r}}function p(t){return t instanceof Date?g(f(t)):null}function w(t){const e=new DataView(t.buffer,t.byteOffset,t.byteLength);switch(t.byteLength){case 4:return{sec:e.getUint32(0),nsec:0};case 8:{const t=e.getUint32(0);return{sec:4294967296*(3&t)+e.getUint32(4),nsec:t>>>2}}case 12:return{sec:l(e,4),nsec:e.getUint32(0)};default:throw new o(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${t.length}`)}}function y(t){const e=w(t);return new Date(1e3*e.sec+e.nsec/1e6)}const b={type:m,encode:p,decode:y};class M{constructor(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(b)}register({type:t,encode:e,decode:i}){if(t>=0)this.encoders[t]=e,this.decoders[t]=i;else{const s=-1-t;this.builtInEncoders[s]=e,this.builtInDecoders[s]=i}}tryToEncode(t,e){for(let i=0;i<this.builtInEncoders.length;i++){const s=this.builtInEncoders[i];if(null!=s){const r=s(t,e);if(null!=r)return new n(-1-i,r)}}for(let i=0;i<this.encoders.length;i++){const s=this.encoders[i];if(null!=s){const r=s(t,e);if(null!=r)return new n(i,r)}}return t instanceof n?t:null}decode(t,e,i){const s=e<0?this.builtInDecoders[-1-e]:this.decoders[e];return s?s(t,e,i):new n(e,t)}}function v(t){return t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):function(t){return t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer}(t)?new Uint8Array(t):Uint8Array.from(t)}M.defaultCodec=new M;class x{constructor(t){this.entered=!1,this.extensionCodec=t?.extensionCodec??M.defaultCodec,this.context=t?.context,this.useBigInt64=t?.useBigInt64??!1,this.maxDepth=t?.maxDepth??100,this.initialBufferSize=t?.initialBufferSize??2048,this.sortKeys=t?.sortKeys??!1,this.forceFloat32=t?.forceFloat32??!1,this.ignoreUndefined=t?.ignoreUndefined??!1,this.forceIntegerToFloat=t?.forceIntegerToFloat??!1,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}clone(){return new x({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,maxDepth:this.maxDepth,initialBufferSize:this.initialBufferSize,sortKeys:this.sortKeys,forceFloat32:this.forceFloat32,ignoreUndefined:this.ignoreUndefined,forceIntegerToFloat:this.forceIntegerToFloat})}reinitializeState(){this.pos=0}encodeSharedRef(t){if(this.entered)return this.clone().encodeSharedRef(t);try{return this.entered=!0,this.reinitializeState(),this.doEncode(t,1),this.bytes.subarray(0,this.pos)}finally{this.entered=!1}}encode(t){if(this.entered)return this.clone().encode(t);try{return this.entered=!0,this.reinitializeState(),this.doEncode(t,1),this.bytes.slice(0,this.pos)}finally{this.entered=!1}}doEncode(t,e){if(e>this.maxDepth)throw new Error(`Too deep objects in depth ${e}`);null==t?this.encodeNil():"boolean"==typeof t?this.encodeBoolean(t):"number"==typeof t?this.forceIntegerToFloat?this.encodeNumberAsFloat(t):this.encodeNumber(t):"string"==typeof t?this.encodeString(t):this.useBigInt64&&"bigint"==typeof t?this.encodeBigInt64(t):this.encodeObject(t,e)}ensureBufferSizeToWrite(t){const e=this.pos+t;this.view.byteLength<e&&this.resizeBuffer(2*e)}resizeBuffer(t){const e=new ArrayBuffer(t),i=new Uint8Array(e),s=new DataView(e);i.set(this.bytes),this.view=s,this.bytes=i}encodeNil(){this.writeU8(192)}encodeBoolean(t){!1===t?this.writeU8(194):this.writeU8(195)}encodeNumber(t){!this.forceIntegerToFloat&&Number.isSafeInteger(t)?t>=0?t<128?this.writeU8(t):t<256?(this.writeU8(204),this.writeU8(t)):t<65536?(this.writeU8(205),this.writeU16(t)):t<4294967296?(this.writeU8(206),this.writeU32(t)):this.useBigInt64?this.encodeNumberAsFloat(t):(this.writeU8(207),this.writeU64(t)):t>=-32?this.writeU8(224|t+32):t>=-128?(this.writeU8(208),this.writeI8(t)):t>=-32768?(this.writeU8(209),this.writeI16(t)):t>=-2147483648?(this.writeU8(210),this.writeI32(t)):this.useBigInt64?this.encodeNumberAsFloat(t):(this.writeU8(211),this.writeI64(t)):this.encodeNumberAsFloat(t)}encodeNumberAsFloat(t){this.forceFloat32?(this.writeU8(202),this.writeF32(t)):(this.writeU8(203),this.writeF64(t))}encodeBigInt64(t){t>=BigInt(0)?(this.writeU8(207),this.writeBigUint64(t)):(this.writeU8(211),this.writeBigInt64(t))}writeStringHeader(t){if(t<32)this.writeU8(160+t);else if(t<256)this.writeU8(217),this.writeU8(t);else if(t<65536)this.writeU8(218),this.writeU16(t);else{if(!(t<4294967296))throw new Error(`Too long string: ${t} bytes in UTF-8`);this.writeU8(219),this.writeU32(t)}}encodeString(t){const e=function(t){const e=t.length;let i=0,s=0;for(;s<e;){let r=t.charCodeAt(s++);if(4294967168&r)if(4294965248&r){if(r>=55296&&r<=56319&&s<e){const e=t.charCodeAt(s);56320==(64512&e)&&(++s,r=((1023&r)<<10)+(1023&e)+65536)}i+=4294901760&r?4:3}else i+=2;else i++}return i}(t);var i,r,a;this.ensureBufferSizeToWrite(5+e),this.writeStringHeader(e),i=t,r=this.bytes,a=this.pos,i.length>50?function(t,e,i){s.encodeInto(t,e.subarray(i))}(i,r,a):function(t,e,i){const s=t.length;let r=i,a=0;for(;a<s;){let i=t.charCodeAt(a++);if(4294967168&i){if(4294965248&i){if(i>=55296&&i<=56319&&a<s){const e=t.charCodeAt(a);56320==(64512&e)&&(++a,i=((1023&i)<<10)+(1023&e)+65536)}4294901760&i?(e[r++]=i>>18&7|240,e[r++]=i>>12&63|128,e[r++]=i>>6&63|128):(e[r++]=i>>12&15|224,e[r++]=i>>6&63|128)}else e[r++]=i>>6&31|192;e[r++]=63&i|128}else e[r++]=i}}(i,r,a),this.pos+=e}encodeObject(t,e){const i=this.extensionCodec.tryToEncode(t,this.context);if(null!=i)this.encodeExtension(i);else if(Array.isArray(t))this.encodeArray(t,e);else if(ArrayBuffer.isView(t))this.encodeBinary(t);else{if("object"!=typeof t)throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(t)}`);this.encodeMap(t,e)}}encodeBinary(t){const e=t.byteLength;if(e<256)this.writeU8(196),this.writeU8(e);else if(e<65536)this.writeU8(197),this.writeU16(e);else{if(!(e<4294967296))throw new Error(`Too large binary: ${e}`);this.writeU8(198),this.writeU32(e)}const i=v(t);this.writeU8a(i)}encodeArray(t,e){const i=t.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else{if(!(i<4294967296))throw new Error(`Too large array: ${i}`);this.writeU8(221),this.writeU32(i)}for(const i of t)this.doEncode(i,e+1)}countWithoutUndefined(t,e){let i=0;for(const s of e)void 0!==t[s]&&i++;return i}encodeMap(t,e){const i=Object.keys(t);this.sortKeys&&i.sort();const s=this.ignoreUndefined?this.countWithoutUndefined(t,i):i.length;if(s<16)this.writeU8(128+s);else if(s<65536)this.writeU8(222),this.writeU16(s);else{if(!(s<4294967296))throw new Error(`Too large map object: ${s}`);this.writeU8(223),this.writeU32(s)}for(const s of i){const i=t[s];this.ignoreUndefined&&void 0===i||(this.encodeString(s),this.doEncode(i,e+1))}}encodeExtension(t){if("function"==typeof t.data){const e=t.data(this.pos+6),i=e.length;if(i>=4294967296)throw new Error(`Too large extension object: ${i}`);return this.writeU8(201),this.writeU32(i),this.writeI8(t.type),void this.writeU8a(e)}const e=t.data.length;if(1===e)this.writeU8(212);else if(2===e)this.writeU8(213);else if(4===e)this.writeU8(214);else if(8===e)this.writeU8(215);else if(16===e)this.writeU8(216);else if(e<256)this.writeU8(199),this.writeU8(e);else if(e<65536)this.writeU8(200),this.writeU16(e);else{if(!(e<4294967296))throw new Error(`Too large extension object: ${e}`);this.writeU8(201),this.writeU32(e)}this.writeI8(t.type),this.writeU8a(t.data)}writeU8(t){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,t),this.pos++}writeU8a(t){const e=t.length;this.ensureBufferSizeToWrite(e),this.bytes.set(t,this.pos),this.pos+=e}writeI8(t){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,t),this.pos++}writeU16(t){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,t),this.pos+=2}writeI16(t){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,t),this.pos+=2}writeU32(t){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,t),this.pos+=4}writeI32(t){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,t),this.pos+=4}writeF32(t){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,t),this.pos+=4}writeF64(t){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,t),this.pos+=8}writeU64(t){this.ensureBufferSizeToWrite(8),function(t,e,i){const s=i/4294967296,r=i;t.setUint32(e,s),t.setUint32(e+4,r)}(this.view,this.pos,t),this.pos+=8}writeI64(t){this.ensureBufferSizeToWrite(8),d(this.view,this.pos,t),this.pos+=8}writeBigUint64(t){this.ensureBufferSizeToWrite(8),this.view.setBigUint64(this.pos,t),this.pos+=8}writeBigInt64(t){this.ensureBufferSizeToWrite(8),this.view.setBigInt64(this.pos,t),this.pos+=8}}function A(t,e){return new x(e).encodeSharedRef(t)}function U(t){return`${t<0?"-":""}0x${Math.abs(t).toString(16).padStart(2,"0")}`}const S="array",W="map_key",D="map_value",k=t=>{if("string"==typeof t||"number"==typeof t)return t;throw new o("The type of key must be string or number but "+typeof t)};class B{constructor(){this.stack=[],this.stackHeadPosition=-1}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(t){const e=this.getUninitializedStateFromPool();e.type=S,e.position=0,e.size=t,e.array=new Array(t)}pushMapState(t){const e=this.getUninitializedStateFromPool();e.type=W,e.readCount=0,e.size=t,e.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const t={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(t)}return this.stack[this.stackHeadPosition]}release(t){if(this.stack[this.stackHeadPosition]!==t)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(t.type===S){const e=t;e.size=0,e.array=void 0,e.position=0,e.type=void 0}if(t.type===W||t.type===D){const e=t;e.size=0,e.map=void 0,e.readCount=0,e.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}const z=new DataView(new ArrayBuffer(0)),E=new Uint8Array(z.buffer);try{z.getInt8(0)}catch(t){if(!(t instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}const I=new RangeError("Insufficient data"),L=new class{constructor(t=16,e=16){this.hit=0,this.miss=0,this.maxKeyLength=t,this.maxLengthPerKey=e,this.caches=[];for(let t=0;t<this.maxKeyLength;t++)this.caches.push([])}canBeCached(t){return t>0&&t<=this.maxKeyLength}find(t,e,i){const s=this.caches[i-1];t:for(const r of s){const s=r.bytes;for(let r=0;r<i;r++)if(s[r]!==t[e+r])continue t;return r.str}return null}store(t,e){const i=this.caches[t.length-1],s={bytes:t,str:e};i.length>=this.maxLengthPerKey?i[Math.random()*i.length|0]=s:i.push(s)}decode(t,e,i){const s=this.find(t,e,i);if(null!=s)return this.hit++,s;this.miss++;const a=r(t,e,i),n=Uint8Array.prototype.slice.call(t,e,e+i);return this.store(n,a),a}};class N{constructor(t){this.totalPos=0,this.pos=0,this.view=z,this.bytes=E,this.headByte=-1,this.stack=new B,this.entered=!1,this.extensionCodec=t?.extensionCodec??M.defaultCodec,this.context=t?.context,this.useBigInt64=t?.useBigInt64??!1,this.rawStrings=t?.rawStrings??!1,this.maxStrLength=t?.maxStrLength??h,this.maxBinLength=t?.maxBinLength??h,this.maxArrayLength=t?.maxArrayLength??h,this.maxMapLength=t?.maxMapLength??h,this.maxExtLength=t?.maxExtLength??h,this.keyDecoder=void 0!==t?.keyDecoder?t.keyDecoder:L,this.mapKeyConverter=t?.mapKeyConverter??k}clone(){return new N({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=-1,this.stack.reset()}setBuffer(t){const e=v(t);this.bytes=e,this.view=new DataView(e.buffer,e.byteOffset,e.byteLength),this.pos=0}appendBuffer(t){if(-1!==this.headByte||this.hasRemaining(1)){const e=this.bytes.subarray(this.pos),i=v(t),s=new Uint8Array(e.length+i.length);s.set(e),s.set(i,e.length),this.setBuffer(s)}else this.setBuffer(t)}hasRemaining(t){return this.view.byteLength-this.pos>=t}createExtraByteError(t){const{view:e,pos:i}=this;return new RangeError(`Extra ${e.byteLength-i} of ${e.byteLength} byte(s) found at buffer[${t}]`)}decode(t){if(this.entered)return this.clone().decode(t);try{this.entered=!0,this.reinitializeState(),this.setBuffer(t);const e=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return e}finally{this.entered=!1}}*decodeMulti(t){if(this.entered){const e=this.clone();return void(yield*e.decodeMulti(t))}try{for(this.entered=!0,this.reinitializeState(),this.setBuffer(t);this.hasRemaining(1);)yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(t){if(this.entered)return this.clone().decodeAsync(t);try{this.entered=!0;let e,i=!1;for await(const s of t){if(i)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(s);try{e=this.doDecodeSync(),i=!0}catch(t){if(!(t instanceof RangeError))throw t}this.totalPos+=this.pos}if(i){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return e}const{headByte:s,pos:r,totalPos:a}=this;throw new RangeError(`Insufficient data in parsing ${U(s)} at ${a} (${r} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(t){return this.decodeMultiAsync(t,!0)}decodeStream(t){return this.decodeMultiAsync(t,!1)}async*decodeMultiAsync(t,e){if(this.entered){const i=this.clone();return void(yield*i.decodeMultiAsync(t,e))}try{this.entered=!0;let i=e,s=-1;for await(const r of t){if(e&&0===s)throw this.createExtraByteError(this.totalPos);this.appendBuffer(r),i&&(s=this.readArraySize(),i=!1,this.complete());try{for(;yield this.doDecodeSync(),0!==--s;);}catch(t){if(!(t instanceof RangeError))throw t}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){t:for(;;){const t=this.readHeadByte();let e;if(t>=224)e=t-256;else if(t<192)if(t<128)e=t;else if(t<144){const i=t-128;if(0!==i){this.pushMapState(i),this.complete();continue t}e={}}else if(t<160){const i=t-144;if(0!==i){this.pushArrayState(i),this.complete();continue t}e=[]}else{const i=t-160;e=this.decodeString(i,0)}else if(192===t)e=null;else if(194===t)e=!1;else if(195===t)e=!0;else if(202===t)e=this.readF32();else if(203===t)e=this.readF64();else if(204===t)e=this.readU8();else if(205===t)e=this.readU16();else if(206===t)e=this.readU32();else if(207===t)e=this.useBigInt64?this.readU64AsBigInt():this.readU64();else if(208===t)e=this.readI8();else if(209===t)e=this.readI16();else if(210===t)e=this.readI32();else if(211===t)e=this.useBigInt64?this.readI64AsBigInt():this.readI64();else if(217===t){const t=this.lookU8();e=this.decodeString(t,1)}else if(218===t){const t=this.lookU16();e=this.decodeString(t,2)}else if(219===t){const t=this.lookU32();e=this.decodeString(t,4)}else if(220===t){const t=this.readU16();if(0!==t){this.pushArrayState(t),this.complete();continue t}e=[]}else if(221===t){const t=this.readU32();if(0!==t){this.pushArrayState(t),this.complete();continue t}e=[]}else if(222===t){const t=this.readU16();if(0!==t){this.pushMapState(t),this.complete();continue t}e={}}else if(223===t){const t=this.readU32();if(0!==t){this.pushMapState(t),this.complete();continue t}e={}}else if(196===t){const t=this.lookU8();e=this.decodeBinary(t,1)}else if(197===t){const t=this.lookU16();e=this.decodeBinary(t,2)}else if(198===t){const t=this.lookU32();e=this.decodeBinary(t,4)}else if(212===t)e=this.decodeExtension(1,0);else if(213===t)e=this.decodeExtension(2,0);else if(214===t)e=this.decodeExtension(4,0);else if(215===t)e=this.decodeExtension(8,0);else if(216===t)e=this.decodeExtension(16,0);else if(199===t){const t=this.lookU8();e=this.decodeExtension(t,1)}else if(200===t){const t=this.lookU16();e=this.decodeExtension(t,2)}else{if(201!==t)throw new o(`Unrecognized type byte: ${U(t)}`);{const t=this.lookU32();e=this.decodeExtension(t,4)}}this.complete();const i=this.stack;for(;i.length>0;){const t=i.top();if(t.type===S){if(t.array[t.position]=e,t.position++,t.position!==t.size)continue t;e=t.array,i.release(t)}else{if(t.type===W){if("__proto__"===e)throw new o("The key __proto__ is not allowed");t.key=this.mapKeyConverter(e),t.type=D;continue t}if(t.map[t.key]=e,t.readCount++,t.readCount!==t.size){t.key=null,t.type=W;continue t}e=t.map,i.release(t)}}return e}}readHeadByte(){return-1===this.headByte&&(this.headByte=this.readU8()),this.headByte}complete(){this.headByte=-1}readArraySize(){const t=this.readHeadByte();switch(t){case 220:return this.readU16();case 221:return this.readU32();default:if(t<160)return t-144;throw new o(`Unrecognized array type byte: ${U(t)}`)}}pushMapState(t){if(t>this.maxMapLength)throw new o(`Max length exceeded: map length (${t}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(t)}pushArrayState(t){if(t>this.maxArrayLength)throw new o(`Max length exceeded: array length (${t}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(t)}decodeString(t,e){return!this.rawStrings||this.stateIsMapKey()?this.decodeUtf8String(t,e):this.decodeBinary(t,e)}decodeUtf8String(t,e){if(t>this.maxStrLength)throw new o(`Max length exceeded: UTF-8 byte length (${t}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+e+t)throw I;const i=this.pos+e;let s;return s=this.stateIsMapKey()&&this.keyDecoder?.canBeCached(t)?this.keyDecoder.decode(this.bytes,i,t):function(t,e,i){return i>200?function(t,e,i){const s=t.subarray(e,e+i);return a.decode(s)}(t,e,i):r(t,e,i)}(this.bytes,i,t),this.pos+=e+t,s}stateIsMapKey(){return this.stack.length>0&&this.stack.top().type===W}decodeBinary(t,e){if(t>this.maxBinLength)throw new o(`Max length exceeded: bin length (${t}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(t+e))throw I;const i=this.pos+e,s=this.bytes.subarray(i,i+t);return this.pos+=e+t,s}decodeExtension(t,e){if(t>this.maxExtLength)throw new o(`Max length exceeded: ext length (${t}) > maxExtLength (${this.maxExtLength})`);const i=this.view.getInt8(this.pos+e),s=this.decodeBinary(t,e+1);return this.extensionCodec.decode(s,i,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const t=this.view.getUint8(this.pos);return this.pos++,t}readI8(){const t=this.view.getInt8(this.pos);return this.pos++,t}readU16(){const t=this.view.getUint16(this.pos);return this.pos+=2,t}readI16(){const t=this.view.getInt16(this.pos);return this.pos+=2,t}readU32(){const t=this.view.getUint32(this.pos);return this.pos+=4,t}readI32(){const t=this.view.getInt32(this.pos);return this.pos+=4,t}readU64(){const t=(e=this.view,i=this.pos,4294967296*e.getUint32(i)+e.getUint32(i+4));var e,i;return this.pos+=8,t}readI64(){const t=l(this.view,this.pos);return this.pos+=8,t}readU64AsBigInt(){const t=this.view.getBigUint64(this.pos);return this.pos+=8,t}readI64AsBigInt(){const t=this.view.getBigInt64(this.pos);return this.pos+=8,t}readF32(){const t=this.view.getFloat32(this.pos);return this.pos+=4,t}readF64(){const t=this.view.getFloat64(this.pos);return this.pos+=8,t}}function F(t,e){return new N(e).decode(t)}function T(t,e){return new N(e).decodeMulti(t)}function $(t){return null!=t[Symbol.asyncIterator]?t:async function*(t){const e=t.getReader();try{for(;;){const{done:t,value:i}=await e.read();if(t)return;yield i}}finally{e.releaseLock()}}(t)}async function H(t,e){const i=$(t);return new N(e).decodeAsync(i)}function O(t,e){const i=$(t);return new N(e).decodeArrayStream(i)}function R(t,e){const i=$(t);return new N(e).decodeStream(i)}},976:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OutputLayer=void 0,e.OutputLayer=class{weights;bias;gradWeights;gradBias;learningRate=.01;vocabSize;embeddingDim;constructor(t,e){this.embeddingDim=t,this.vocabSize=e;const i=Math.sqrt(1/(t+e));this.weights=Array.from({length:t},()=>Array.from({length:e},()=>(2*Math.random()-1)*i)),this.bias=Array.from({length:e},()=>0),this.gradWeights=Array.from({length:t},()=>Array.from({length:e},()=>0)),this.gradBias=Array.from({length:e},()=>0)}forward(t){const e=new Array(this.vocabSize).fill(0);for(let i=0;i<this.vocabSize;i++){let s=this.bias[i];for(let e=0;e<this.embeddingDim;e++)s+=t[e]*this.weights[e][i];e[i]=s}return e}softmax(t){const e=Math.max(...t),i=t.map(t=>Math.exp(t-e)),s=i.reduce((t,e)=>t+e,1e-8);return i.map(t=>t/s)}backward(t,e){const i=new Array(this.embeddingDim).fill(0);for(let s=0;s<this.embeddingDim;s++)for(let r=0;r<this.vocabSize;r++)this.gradWeights[s][r]+=e[r]*t[s],i[s]+=e[r]*this.weights[s][r];for(let t=0;t<this.vocabSize;t++)this.gradBias[t]+=e[t];return i}zeroGrad(){for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.vocabSize;e++)this.gradWeights[t][e]=0;for(let t=0;t<this.vocabSize;t++)this.gradBias[t]=0}updateParameters(){for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.vocabSize;e++){const i=Math.max(-1,Math.min(1,this.gradWeights[t][e]));this.weights[t][e]-=this.learningRate*i}for(let t=0;t<this.vocabSize;t++){const e=Math.max(-1,Math.min(1,this.gradBias[t]));this.bias[t]-=this.learningRate*e}}updateWithOptimizer(t){const e=this.gradWeights.map(t=>t.map(t=>Math.max(-5,Math.min(5,t)))),i=this.gradBias.map(t=>Math.max(-5,Math.min(5,t)));t.update("output_weights",this.weights,e),t.update1D("output_bias",this.bias,i)}}}},e={};function i(s){var r=e[s];if(void 0!==r)return r.exports;var a=e[s]={exports:{}};return t[s](a,a.exports,i),a.exports}i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{const t=i(396);let e,s=!1;async function r(i="default-latest"){const r=document.getElementById("status"),a=document.getElementById("output"),n=document.getElementById("predict-button"),o=document.getElementById("user-input");r.textContent=`Loading model from repository: ${i}...`,a.innerHTML="";const h=await async function(e="default-latest"){try{const i=await fetch(`./models/${e}.msgpack`);if(!i.ok)return console.warn(`Model file not found: models/${e}.msgpack`),null;const s=await i.arrayBuffer(),r=new Uint8Array(s),a=t.SimpleLLM.deserialize(r);return console.log("Model loaded from repository:",e),a}catch(t){return console.error("Error loading model from repo:",t),null}}(i);if(h)try{e=h,s=!0,n.disabled=!1,o.disabled=!1;const t=document.createElement("div");t.className="message success",t.textContent=" Model loaded successfully! You can start chatting now.",a.appendChild(t);const i=document.createElement("div");i.className="message",i.innerHTML=`\n        <strong>Model Info:</strong><br>\n        - Vocab size: ${e.vocabSize}<br>\n        - Embedding dimension: ${e.embeddingDim}<br>\n        - Number of layers: ${e.numLayers}<br>\n        - Number of heads: ${e.numHeads}\n      `,a.appendChild(i),r.textContent="Model ready! Start chatting below."}catch(t){console.error("Error loading model:",t);const e=document.createElement("div");e.className="message error",e.textContent=" Failed to load model. Please check the console for details.",a.appendChild(e),r.textContent="Failed to load model"}else{const t=document.createElement("div");t.className="message error",t.textContent=" Model file not found. Please ensure default-latest.msgpack exists in the models directory.",a.appendChild(t),r.textContent="Model not found"}}async function a(){await r();const t=document.getElementById("predict-button"),i=document.getElementById("user-input"),a=document.getElementById("output"),n=document.getElementById("model-select"),o=document.getElementById("load-model-button");t.addEventListener("click",()=>{const t=i.value.trim();if(t)if(s)try{const s=e.predict(t,10),r=document.createElement("div");r.className="message user-message",r.textContent=`You: ${t}`,a.appendChild(r);const n=document.createElement("div");n.className="message ai-message",n.textContent=`AI: ${s}`,a.appendChild(n),a.scrollTop=a.scrollHeight,i.value=""}catch(t){const e=document.createElement("div");e.className="message error",e.textContent=`Error: ${t}`,a.appendChild(e),console.error(t)}else alert("Model is not ready yet. Please wait for it to load.");else alert("Please enter some text")}),i.addEventListener("keypress",e=>{"Enter"===e.key&&t.click()}),o.addEventListener("click",async()=>{const e=n.value;t.disabled=!0,i.disabled=!0,o.disabled=!0,await r(e),o.disabled=!1})}"loading"===document.readyState?document.addEventListener("DOMContentLoaded",a):a()})()})();