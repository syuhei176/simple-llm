(()=>{"use strict";var t={179:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.OutputLayer=void 0,e.OutputLayer=class{weights;bias;gradWeights;gradBias;learningRate=.001;vocabSize;embeddingDim;constructor(t,e){this.embeddingDim=t,this.vocabSize=e;const a=Math.sqrt(1/(t+e));this.weights=Array.from({length:t},()=>Array.from({length:e},()=>(2*Math.random()-1)*a)),this.bias=Array.from({length:e},()=>0),this.gradWeights=Array.from({length:t},()=>Array.from({length:e},()=>0)),this.gradBias=Array.from({length:e},()=>0)}forward(t){const e=new Array(this.vocabSize).fill(0);for(let a=0;a<this.vocabSize;a++){let s=this.bias[a];for(let e=0;e<this.embeddingDim;e++)s+=t[e]*this.weights[e][a];e[a]=s}return e}softmax(t){const e=Math.max(...t),a=t.map(t=>Math.exp(t-e)),s=a.reduce((t,e)=>t+e,1e-8);return a.map(t=>t/s)}backward(t,e){const a=new Array(this.embeddingDim).fill(0);for(let s=0;s<this.embeddingDim;s++)for(let i=0;i<this.vocabSize;i++)this.gradWeights[s][i]+=e[i]*t[s],a[s]+=e[i]*this.weights[s][i];for(let t=0;t<this.vocabSize;t++)this.gradBias[t]+=e[t];return a}zeroGrad(){for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.vocabSize;e++)this.gradWeights[t][e]=0;for(let t=0;t<this.vocabSize;t++)this.gradBias[t]=0}updateParameters(){for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.vocabSize;e++){const a=Math.max(-5,Math.min(5,this.gradWeights[t][e]));this.weights[t][e]+=this.learningRate*a}for(let t=0;t<this.vocabSize;t++){const e=Math.max(-5,Math.min(5,this.gradBias[t]));this.bias[t]+=this.learningRate*e}}}},211:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.SimpleTokenizer=void 0,e.SimpleTokenizer=class{vocab;vocabMap;unkIndex;constructor(t){this.vocab=t,this.vocabMap=Object.fromEntries(t.map((t,e)=>[t,e])),this.unkIndex=this.vocabMap["[UNK]"]??0}encode(t){return t.toLowerCase().split(" ").map(t=>t.trim()).filter(t=>t.length>0).map(t=>this.vocabMap[t]??this.unkIndex)}decode(t){return t.map(t=>this.vocab[t]??"[UNK]").join(" ")}}},499:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.EmbeddingLayer=void 0,e.EmbeddingLayer=class{weights;embeddingDim;learningRate=.001;constructor(t,e){this.embeddingDim=e;const a=Math.sqrt(1/e);this.weights=Array.from({length:t},()=>Array.from({length:e},()=>(2*Math.random()-1)*a))}forward(t){return t<0||t>=this.weights.length?Array(this.embeddingDim).fill(0):[...this.weights[t]]}backward(t,e){if(!(t<0||t>=this.weights.length))for(let a=0;a<this.embeddingDim;a++){const s=Math.max(-5,Math.min(5,e[a]));this.weights[t][a]+=this.learningRate*s}}}},591:(t,e)=>{function a(t,e=1e-8){const a=t.reduce((t,e)=>t+e,0)/t.length,s=t.reduce((t,e)=>t+Math.pow(e-a,2),0)/t.length,i=Math.sqrt(s+e);return{normalized:t.map(t=>(t-a)/i),mean:a,std:i}}Object.defineProperty(e,"__esModule",{value:!0}),e.LayerNorm=void 0,e.layerNormalize=a,e.batchLayerNormalize=function(t,e=1e-8){return t.map(t=>a(t,e).normalized)},e.LayerNorm=class{epsilon;gamma;beta;dim;learningRate=.001;gradGamma;gradBeta;lastMean=[];lastVar=[];lastStd=[];lastNormalized=[];lastInput=[];constructor(t,e=1e-8){this.dim=t,this.epsilon=e,this.gamma=Array(t).fill(1),this.beta=Array(t).fill(0),this.gradGamma=Array(t).fill(0),this.gradBeta=Array(t).fill(0)}forward(t){const e=t.reduce((t,e)=>t+e,0)/this.dim,a=t.reduce((t,a)=>t+Math.pow(a-e,2),0)/this.dim,s=Math.sqrt(a+this.epsilon);return t.map(t=>(t-e)/s).map((t,e)=>this.gamma[e]*t+this.beta[e])}forwardBatch(t){return this.lastInput=t.map(t=>[...t]),this.lastMean=[],this.lastVar=[],this.lastStd=[],this.lastNormalized=[],t.map((t,e)=>{const a=t.reduce((t,e)=>t+e,0)/this.dim,s=t.reduce((t,e)=>t+Math.pow(e-a,2),0)/this.dim,i=Math.sqrt(s+this.epsilon);this.lastMean[e]=a,this.lastVar[e]=s,this.lastStd[e]=i;const r=t.map(t=>(t-a)/i);return this.lastNormalized[e]=[...r],r.map((t,e)=>this.gamma[e]*t+this.beta[e])})}backward(t,e,a){const s=this.dim,i=(this.lastMean[a],this.lastStd[a]),r=this.lastNormalized[a];for(let t=0;t<s;t++)this.gradGamma[t]+=e[t]*r[t],this.gradBeta[t]+=e[t];const o=e.map((t,e)=>t*this.gamma[e]),n=o.reduce((t,e)=>t+e,0)/s,l=o.reduce((t,e,a)=>t+e*r[a],0)/s;return o.map((t,e)=>(t-n-r[e]*l)/i)}zeroGrad(){this.gradGamma.fill(0),this.gradBeta.fill(0)}updateParameters(){for(let t=0;t<this.dim;t++){const e=Math.max(-5,Math.min(5,this.gradGamma[t])),a=Math.max(-5,Math.min(5,this.gradBeta[t]));this.gamma[t]+=this.learningRate*e,this.beta[t]+=this.learningRate*a}}backwardBatch(t,e){return t.map((t,a)=>this.backward(t,e[a],a))}}},673:(t,e,a)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.SimpleTransformer=void 0;const s=a(591);e.SimpleTransformer=class{wq;wk;wv;w1;w2;gradWq;gradWk;gradWv;gradW1;gradW2;layerNorm1;layerNorm2;learningRate=.001;embeddingDim;lastInput=[];lastQ=[];lastK=[];lastV=[];lastScores=[];lastAttentionWeights=[];lastAttnOutput=[];lastAttnResidual=[];lastAttnNorm=[];lastFF1=[];lastFFOutput=[];lastFFResidual=[];constructor(t){this.embeddingDim=t;const e=Math.sqrt(1/t);this.wq=this.initWeights(t,t,e),this.wk=this.initWeights(t,t,e),this.wv=this.initWeights(t,t,e),this.w1=this.initWeights(t,t,e),this.w2=this.initWeights(t,t,e),this.gradWq=this.initWeights(t,t,0),this.gradWk=this.initWeights(t,t,0),this.gradWv=this.initWeights(t,t,0),this.gradW1=this.initWeights(t,t,0),this.gradW2=this.initWeights(t,t,0),this.layerNorm1=new s.LayerNorm(t),this.layerNorm2=new s.LayerNorm(t)}initWeights(t,e,a){return Array.from({length:t},()=>Array.from({length:e},()=>(2*Math.random()-1)*a))}matmul(t,e){const a=[];for(let s=0;s<t.length;s++){a[s]=[];for(let i=0;i<e[0].length;i++){let r=0;for(let a=0;a<t[0].length;a++)r+=t[s][a]*e[a][i];a[s][i]=r}}return a}vecMatmul(t,e){const a=new Array(e[0].length).fill(0);for(let s=0;s<e[0].length;s++)for(let i=0;i<t.length;i++)a[s]+=t[i]*e[i][s];return a}transpose(t){const e=t.length,a=t[0].length,s=Array.from({length:a},()=>new Array(e));for(let i=0;i<e;i++)for(let e=0;e<a;e++)s[e][i]=t[i][e];return s}softmax(t){return t.map(t=>{const e=Math.max(...t),a=t.map(t=>Math.exp(t-e)),s=a.reduce((t,e)=>t+e,1e-8);return a.map(t=>t/s)})}softmaxBackward(t,e){const a=[];for(let s=0;s<t.length;s++){const i=e[s],r=t[s],o=r.reduce((t,e,a)=>t+e*i[a],0);a[s]=i.map((t,e)=>t*(r[e]-o))}return a}attention(t){const e=t.length,a=Math.sqrt(this.embeddingDim);this.lastQ=t.map(t=>this.vecMatmul(t,this.wq)),this.lastK=t.map(t=>this.vecMatmul(t,this.wk)),this.lastV=t.map(t=>this.vecMatmul(t,this.wv)),this.lastScores=[];for(let t=0;t<e;t++){this.lastScores[t]=[];for(let s=0;s<e;s++){let e=0;for(let a=0;a<this.embeddingDim;a++)e+=this.lastQ[t][a]*this.lastK[s][a];this.lastScores[t][s]=e/a}}this.lastAttentionWeights=this.softmax(this.lastScores);const s=[];for(let t=0;t<e;t++){s[t]=new Array(this.embeddingDim).fill(0);for(let a=0;a<e;a++)for(let e=0;e<this.embeddingDim;e++)s[t][e]+=this.lastAttentionWeights[t][a]*this.lastV[a][e]}return s}feedForward(t){return this.lastFF1=t.map(t=>this.vecMatmul(t,this.w1).map(t=>Math.max(0,t))),this.lastFF1.map(t=>this.vecMatmul(t,this.w2))}forward(t){return this.lastInput=t.map(t=>[...t]),this.lastAttnOutput=this.attention(t),this.lastAttnResidual=this.lastAttnOutput.map((e,a)=>e.map((e,s)=>e+t[a][s])),this.lastAttnNorm=this.layerNorm1.forwardBatch(this.lastAttnResidual),this.lastFFOutput=this.feedForward(this.lastAttnNorm),this.lastFFResidual=this.lastFFOutput.map((t,e)=>t.map((t,a)=>t+this.lastAttnNorm[e][a])),this.layerNorm2.forwardBatch(this.lastFFResidual)}backward(t){const e=t.length,a=Math.sqrt(this.embeddingDim);let s=this.layerNorm2.backwardBatch(this.lastFFResidual,t);const i=s.map(t=>[...t]),r=s.map(t=>[...t]),o=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const a=i[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradW2[s][e]+=a*this.lastFF1[t][s],o[t][s]+=a*this.w2[s][e]}const n=o.map((t,e)=>t.map((t,a)=>this.lastFF1[e][a]>0?t:0));for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const a=n[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradW1[s][e]+=a*this.lastAttnNorm[t][s],r[t][s]+=a*this.w1[s][e]}const l=this.layerNorm1.backwardBatch(this.lastAttnResidual,r),h=l.map(t=>[...t]),d=l.map(t=>[...t]),m=Array.from({length:e},()=>new Array(e).fill(0)),c=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let a=0;a<this.embeddingDim;a++){const s=h[t][a];for(let i=0;i<e;i++)m[t][i]+=s*this.lastV[i][a],c[i][a]+=s*this.lastAttentionWeights[t][i]}const g=this.softmaxBackward(m,this.lastAttentionWeights).map(t=>t.map(t=>t/a)),u=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0)),f=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let a=0;a<e;a++){const e=g[t][a];for(let s=0;s<this.embeddingDim;s++)u[t][s]+=e*this.lastK[a][s],f[a][s]+=e*this.lastQ[t][s]}const p=Array.from({length:e},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const a=u[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradWq[s][e]+=a*this.lastInput[t][s],p[t][s]+=a*this.wq[s][e]}for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const a=f[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradWk[s][e]+=a*this.lastInput[t][s],p[t][s]+=a*this.wk[s][e]}for(let t=0;t<e;t++)for(let e=0;e<this.embeddingDim;e++){const a=c[t][e];for(let s=0;s<this.embeddingDim;s++)this.gradWv[s][e]+=a*this.lastInput[t][s],p[t][s]+=a*this.wv[s][e]}return d.map((t,e)=>t.map((t,a)=>t+p[e][a]))}zeroGrad(){for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.embeddingDim;e++)this.gradWq[t][e]=0,this.gradWk[t][e]=0,this.gradWv[t][e]=0,this.gradW1[t][e]=0,this.gradW2[t][e]=0}updateParameters(){for(let t=0;t<this.embeddingDim;t++)for(let e=0;e<this.embeddingDim;e++){const a=Math.max(-5,Math.min(5,this.gradWq[t][e]));this.wq[t][e]+=this.learningRate*a;const s=Math.max(-5,Math.min(5,this.gradWk[t][e]));this.wk[t][e]+=this.learningRate*s;const i=Math.max(-5,Math.min(5,this.gradWv[t][e]));this.wv[t][e]+=this.learningRate*i;const r=Math.max(-5,Math.min(5,this.gradW1[t][e]));this.w1[t][e]+=this.learningRate*r;const o=Math.max(-5,Math.min(5,this.gradW2[t][e]));this.w2[t][e]+=this.learningRate*o}}}},685:(t,e,a)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.SimpleLLM=void 0;const s=a(211),i=a(673),r=a(499),o=a(179),n=a(893);class l{tokenizer;embedding;transformers;outputLayer;positionalEncoding;vocabSize;embeddingDim;numLayers;constructor(t,e=16,a=2){this.vocabSize=t.length,this.embeddingDim=e,this.numLayers=a,this.tokenizer=new s.SimpleTokenizer(t),this.embedding=new r.EmbeddingLayer(t.length,e),this.transformers=Array.from({length:a},()=>new i.SimpleTransformer(e)),this.outputLayer=new o.OutputLayer(e,t.length),this.positionalEncoding=new n.PositionalEncodingCache(e)}getSpecialTokenIndices(){const t=new Set;return["[PAD]","[UNK]","[EOS]"].forEach(e=>{const a=this.tokenizer.vocabMap[e];void 0!==a&&t.add(a)}),t}predict(t,e=10){let a=this.tokenizer.encode(t);const s=this.getSpecialTokenIndices(),i=this.tokenizer.vocabMap["[EOS]"];console.log("Input text:",t),console.log("Encoded tokens:",a),console.log("Special token indices:",Array.from(s)),console.log("Vocab size:",this.vocabSize);for(let t=0;t<e;t++){const e=a.map(t=>this.embedding.forward(t));let r=this.positionalEncoding.addToEmbeddings(e);for(const t of this.transformers)r=t.forward(r);const o=r[r.length-1],n=this.outputLayer.forward(o),l=this.outputLayer.softmax(n),h=l.map((t,e)=>({prob:t,idx:e,word:this.tokenizer.vocab[e]})).sort((t,e)=>e.prob-t.prob).slice(0,5);console.log(`Step ${t} - Top 5 probs (before filter):`,h);const d=l.map((t,e)=>s.has(e)?0:t),m=d.reduce((t,e)=>t+e,1e-10),c=d.map(t=>t/m),g=Math.max(...c),u=c.indexOf(g);console.log(`Step ${t}: nextToken=${u}, maxProb=${g.toFixed(4)}, word="${this.tokenizer.vocab[u]}"`);const f=c.map((t,e)=>({prob:t,idx:e,word:this.tokenizer.vocab[e]})).sort((t,e)=>e.prob-t.prob).slice(0,5);if(console.log(`Step ${t} - Top 5 probs (after filter):`,f),a.push(u),u===i)break}const r=this.tokenizer.decode(a);return console.log("Final result:",r),r}train(t,e=10){for(let a=0;a<e;a++){let s=0;t.forEach(({input:t,target:e})=>{for(const t of this.transformers)t.zeroGrad(),t.layerNorm1.zeroGrad(),t.layerNorm2.zeroGrad();this.outputLayer.zeroGrad();const a=this.tokenizer.encode(t),i=this.tokenizer.encode(e),r=a.map(t=>this.embedding.forward(t));let o=this.positionalEncoding.addToEmbeddings(r);for(const t of this.transformers)o=t.forward(o);const n=o,l=Math.min(n.length,i.length),h=Array.from({length:n.length},()=>new Array(this.embeddingDim).fill(0));for(let t=0;t<l;t++){const e=this.outputLayer.forward(n[t]),a=this.outputLayer.softmax(e),r=a.map(t=>-t);r[i[t]]+=1,s-=Math.log(a[i[t]]+1e-10);const o=this.outputLayer.backward(n[t],r);for(let e=0;e<this.embeddingDim;e++)h[t][e]=o[e]}let d=h;for(let t=this.transformers.length-1;t>=0;t--)d=this.transformers[t].backward(d);const m=d;for(let t=0;t<a.length&&t<m.length;t++)this.embedding.backward(a[t],m[t]);this.outputLayer.updateParameters();for(const t of this.transformers)t.updateParameters(),t.layerNorm1.updateParameters(),t.layerNorm2.updateParameters()});const i=s/t.length;console.log(`Epoch ${a+1}/${e} - Loss: ${i.toFixed(4)}`)}}serialize(){return{version:"1.0",config:{vocabSize:this.vocabSize,embeddingDim:this.embeddingDim,numLayers:this.numLayers,vocab:this.tokenizer.vocab},weights:{embedding:this.embedding.weights,transformers:this.transformers.map(t=>({wq:t.wq,wk:t.wk,wv:t.wv,w1:t.w1,w2:t.w2,layerNorm1:{gamma:t.layerNorm1.gamma,beta:t.layerNorm1.beta},layerNorm2:{gamma:t.layerNorm2.gamma,beta:t.layerNorm2.beta}})),output:{weights:this.outputLayer.weights,bias:this.outputLayer.bias}}}}static deserialize(t){const{config:e,weights:a}=t,s=new l(e.vocab,e.embeddingDim,e.numLayers);return s.embedding.weights=a.embedding,a.transformers.forEach((t,e)=>{s.transformers[e].wq=t.wq,s.transformers[e].wk=t.wk,s.transformers[e].wv=t.wv,s.transformers[e].w1=t.w1,s.transformers[e].w2=t.w2,s.transformers[e].layerNorm1.gamma=t.layerNorm1.gamma,s.transformers[e].layerNorm1.beta=t.layerNorm1.beta,s.transformers[e].layerNorm2.gamma=t.layerNorm2.gamma,s.transformers[e].layerNorm2.beta=t.layerNorm2.beta}),s.outputLayer.weights=a.output.weights,s.outputLayer.bias=a.output.bias,s}}e.SimpleLLM=l},893:(t,e)=>{function a(t,e){const a=new Array(e);for(let s=0;s<e;s++){const i=t/Math.pow(1e4,2*Math.floor(s/2)/e);a[s]=s%2==0?Math.sin(i):Math.cos(i)}return a}Object.defineProperty(e,"__esModule",{value:!0}),e.PositionalEncodingCache=void 0,e.getPositionalEncoding=a,e.addPositionalEncoding=function(t,e){return t.map((t,s)=>{const i=a(s,e);return t.map((t,e)=>t+i[e])})},e.PositionalEncodingCache=class{cache=new Map;embeddingDim;constructor(t){this.embeddingDim=t}get(t){const e=`${t}`;if(!this.cache.has(e)){const s=a(t,this.embeddingDim);this.cache.set(e,s)}return this.cache.get(e)}addToEmbedding(t,e){const a=this.get(e);return t.map((t,e)=>t+a[e])}addToEmbeddings(t){return t.map((t,e)=>this.addToEmbedding(t,e))}}}},e={};function a(s){var i=e[s];if(void 0!==i)return i.exports;var r=e[s]={exports:{}};return t[s](r,r.exports,a),r.exports}(()=>{const t=a(685);let e,s=!1;async function i(){await async function(){const a=document.getElementById("status"),i=document.getElementById("output"),r=document.getElementById("predict-button"),o=document.getElementById("user-input");a.textContent="Loading model from repository...";const n=await async function(t="default-latest"){try{const e=await fetch(`./models/${t}.json`);if(!e.ok)return console.warn(`Model file not found: models/${t}.json`),null;const a=await e.json();return console.log("Model loaded from repository:",t),a}catch(t){return console.error("Error loading model from repo:",t),null}}("default-latest");if(n)try{e=t.SimpleLLM.deserialize(n),s=!0,r.disabled=!1,o.disabled=!1;const l=document.createElement("div");if(l.className="message success",l.textContent="✓ Model loaded successfully! You can start chatting now.",i.appendChild(l),n.metadata){const t=document.createElement("div");t.className="message",t.innerHTML=`\n          <strong>Model Info:</strong><br>\n          - Name: ${n.metadata.name||"N/A"}<br>\n          - Training samples: ${n.metadata.trainingSamples||"N/A"}<br>\n          - Vocab size: ${n.config.vocabSize||"N/A"}<br>\n          - Created: ${n.metadata.createdAt?new Date(n.metadata.createdAt).toLocaleString():"N/A"}\n        `,i.appendChild(t)}a.textContent="Model ready! Start chatting below."}catch(t){console.error("Error deserializing model:",t);const e=document.createElement("div");e.className="message error",e.textContent="✗ Failed to load model. Please check the console for details.",i.appendChild(e),a.textContent="Failed to load model"}else{const t=document.createElement("div");t.className="message error",t.textContent="✗ Model file not found. Please ensure default-latest.json exists in the models directory.",i.appendChild(t),a.textContent="Model not found"}}();const a=document.getElementById("predict-button"),i=document.getElementById("user-input"),r=document.getElementById("output");a.addEventListener("click",()=>{const t=i.value.trim();if(t)if(s)try{const a=e.predict(t,10),s=document.createElement("div");s.className="message user-message",s.textContent=`You: ${t}`,r.appendChild(s);const o=document.createElement("div");o.className="message ai-message",o.textContent=`AI: ${a}`,r.appendChild(o),r.scrollTop=r.scrollHeight,i.value=""}catch(t){const e=document.createElement("div");e.className="message error",e.textContent=`Error: ${t}`,r.appendChild(e),console.error(t)}else alert("Model is not ready yet. Please wait for it to load.");else alert("Please enter some text")}),i.addEventListener("keypress",t=>{"Enter"===t.key&&a.click()})}"loading"===document.readyState?document.addEventListener("DOMContentLoaded",i):i()})()})();